let nat_prev = fun (n: Nat) =>
  match n with
	| Succ n1 => Some {Nat} n1
	| Zero => None {Nat}
	end in

let is_some_zero = fun (n: Nat) =>
	match n with
  | Some Zero => True
  | _ => False
	end in

let nat_eq = fun (n : Nat) => fun (m : Nat) =>
  let z = Some {Nat} m in
		let f = fun (res : Option Nat) => fun (n : Nat) =>
      match res with
      | None => None
      | Some m1 => nat_prev m1
			end in
	let folder = @nat_fold (Option Nat) in
  let e = folder f z n in
  match e with
  | Some Zero => True
  | _ => False
	end in

let int_to_nat_helper =
  tfun 'A =>
  fun (n : 'A) =>
    let m = builtin to_uint32 n in
    match m with
    | Some x =>
      let res = builtin to_nat x in
      Some {Nat} res
    | None => None {Nat}
    end
in

let uint32_to_nat = @int_to_nat_helper Uint32 in
let uint64_to_nat = @int_to_nat_helper Uint64 in
let uint128_to_nat = @int_to_nat_helper Uint128 in
let int32_to_nat = @int_to_nat_helper Int32 in
let int64_to_nat = @int_to_nat_helper Int64 in
let int128_to_nat = @int_to_nat_helper Int128 in

let zero_uint = Uint32 0 in
let zero_nat1 = builtin to_nat zero_uint in
let zero_nat2 = Zero in

let three_uint = Uint32 3 in
let three_nat1 = builtin to_nat three_uint in
let one_nat2 = Succ zero_nat2 in
let two_nat2 = Succ one_nat2 in
let three_nat2 = Succ two_nat2 in


let res1 = nat_eq zero_nat1 zero_nat2 in (* True *)
let res2 = nat_eq three_nat1 three_nat2 in (* True *)

let minus_one_int = Int32 -1 in
let one_int = Int64 1 in

let res3 = int32_to_nat minus_one_int in (* None {Nat} *)
let one_int_nat_opt = int64_to_nat one_int in
let one_int_nat =
  match one_int_nat_opt with
  | Some a => a
  | None => Zero
  end
in

let res4 = nat_eq one_nat2 one_int_nat in (* True *)
Zero
