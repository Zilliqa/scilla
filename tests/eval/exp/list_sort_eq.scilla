let list_head =
  tfun 'A =>
  fun (l : List 'A) =>
    match l with
    | Cons h t =>
      Some {'A} h
    | Nil =>
      None {'A}
    end
in
  
let list_tail =
  tfun 'A =>
  fun (l : List 'A) =>
    match l with
    | Cons h t =>
      Some {'A} t
    | Nil =>
      None {'A}
    end
in
  
(* Returns Some Nil on successul match. None otherwise. *)
let list_eq_helper =
  tfun 'A =>
  fun (eq : 'A -> 'A -> Bool) =>
  fun (l1 : List 'A) =>
  fun (l2 : List 'A) =>
    let folder = @list_foldl 'A (Option (List 'A)) in
    let init = Some l2 in
    let iter =
      fun (z : Option (List 'A)) =>
      fun (h1 : 'A) =>
        match z with
        | Some ll2 =>
          let headF = @list_head 'A in
          let h2o = headF ll2 in
          match h2o with
          | Some h2 =>
            let eqb = eq h1 h2 in
            match eqb with
            | True =>
              let tailF = @list_tail 'A in
              tailF ll2
            | False =>
              None
            end
          | None =>
            None
          end
        | None =>
          None
        end
    in
      folder iter init l1
in

let list_eq =
  tfun 'A =>
  fun (f : 'A -> 'A -> Bool) =>
  fun (l1 : List 'A) =>
  fun (l2 : List 'A) =>
    let eqh = @list_eq_helper 'A in
    let res = eqh f l1 l2 in
    match res with
    | Some l =>
      match l with
      | Nil =>
        True
      | _ =>
        False
      end
    | _ =>
      False
    end
in
  
let list_int_eq_t = @list_eq Uint64 in

let int_eq =
  fun (a : Uint64) =>
  fun (b : Uint64) =>
    builtin eq a b
in

let list_int_eq = list_int_eq_t int_eq in

let list_sort =
  (* Insertion sort *)
  tfun 'A =>
  fun (flt : 'A -> 'A -> Bool) =>
  fun (ls : List 'A) =>
    let true = True in 
    let false = False in
    let rec_A_A = @list_foldr 'A (List 'A) in
    let rec_A_Pair = @list_foldr 'A (Pair Bool (List 'A))  in
    let nil_A = Nil {'A} in 
    let sink_down =
      fun (e : 'A) => fun (ls : List 'A) =>
        let init = Pair {Bool (List 'A)} false nil_A in
        let iter1 =
          fun (h : 'A) =>
          fun (res : Pair Bool (List 'A)) =>
            match res with
            | Pair True rest =>
              let z = Cons {'A} h rest in
              Pair {Bool (List 'A)} true z
            | Pair False rest =>
              let bl = flt h e in
              match bl with
              | True =>
                let z = Cons {'A} e rest in
                let z2 = Cons {'A} h z in
                Pair {Bool (List 'A)} true z2
              | False =>
                let z = Cons {'A} h rest in
                Pair {Bool (List 'A)} false z
              end
            end   
        in
        let res1 = rec_A_Pair iter1 init ls in
        match res1 with
        | Pair True ls1 => ls1
        | Pair False ls1 => Cons {'A} e ls1
        end
    in
    let iter2 =
      fun (h : 'A) =>
      fun (res : List 'A) =>
        sink_down h res
    in 
      rec_A_A iter2 nil_A ls
in

let int_sort_t = @list_sort Uint64 in

let flt =
  fun (a : Uint64) =>
  fun (b : Uint64) =>
    builtin lt a b
in
    
let int_sort = int_sort_t flt in

let zero = Uint64 0 in
let one = Uint64 1 in
let two = Uint64 2 in
let three = Uint64 3 in
let four = Uint64 4 in

let nil = Nil {Uint64} in
let l0 = Cons {Uint64} two nil in
let l1 = Cons {Uint64} one l0 in
let l2 = Cons {Uint64} three l1 in
(* l3 = [4; 3; 1; 2] *)
let l3 = Cons {Uint64} four l2 in

let m0 = Cons {Uint64} four nil in
let m1 = Cons {Uint64} three m0 in
let m2 = Cons {Uint64} two m1 in
(* l3 = [1; 2; 3; 4] *)
let m3 = Cons {Uint64} one m2 in

let res1 = int_sort l3 in

list_int_eq res1 m3
