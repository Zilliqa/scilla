let list_reverse =
  tfun 'A =>
  fun (l : List 'A) =>
    let folder = @list_foldl 'A (List 'A) in
    let init = Nil in
    let iter =
      fun (z : List 'A) =>
      fun (h : 'A) =>
        Cons {'A} h z
    in
      folder iter init l
in

(* ('A -> 'A -> Bool) -> 'A -> List 'A -> List 'A *)
(* Returns the input list "l", in order, excluding the first occurrence *)
(* of an element in it that compares equal to "a" (as compared by "f") *)
let list_skip_once =
  tfun 'A =>
  fun (ff : 'A -> 'A -> Bool) =>
  fun (aa : 'A) =>
  fun (ll : List 'A) =>
    let skip_once_helper =
      tfun 'A =>
      fun (f : 'A -> 'A -> Bool) =>
      fun (a : 'A) =>
      fun (l : List 'A) =>
        let folder = @list_foldl 'A (Pair Bool (List 'A)) in
        let false = False in
        let nil = Nil in
        let init = Pair {Bool (List 'A)} false nil in
        let iter =
          fun (z : Pair Bool (List 'A)) =>
          fun (h : 'A) =>
            match z with
            | Pair True x =>
              let true = True in
              let newl = Cons {'A} h x in
              Pair {Bool (List 'A)} true newl
            | Pair False x =>
              let res = f h a in
              match res with
              | True =>
                let true = True in
                Pair {Bool (List 'A)} true x
              | False =>
                let false = False in
                let newl = Cons {'A} h x in
                Pair {Bool (List 'A)} false newl
              end
            end
      in
        folder iter init l
    in
    let helper = @skip_once_helper 'A in
    let res = helper ff aa ll in
    match res with
    | Pair _ x =>
      let reverser = @list_reverse 'A in
      reverser x
    end
in

(* ('A -> 'A -> Bool) -> List 'A -> Option 'A *)
(* Returns Some maximum element of List 'A, as compared *)
(* by the "lesser-than" comparison function "f". *)
(* Return None iff the input list is empty. *)
let list_max =
  tfun 'A =>
  fun (f : 'A -> 'A -> Bool) =>
  fun (l : List 'A) =>
    let folder = @list_foldl 'A (Option 'A) in
    let init = None in
    let iter =
      fun (z : Option 'A) =>
      fun (h : 'A) =>
        match z with
        | Some zz =>
          let lt = f zz h in
          match lt with
          | True =>
            Some h
          | False =>
            z
          end
        | None =>
          Some h
        end
    in
      folder iter init l
in

let list_head =
  tfun 'A =>
  fun (l : List 'A) =>
    match l with
    | Cons h t =>
      Some h
    | Nil =>
      None
    end
in
  
let list_tail =
  tfun 'A =>
  fun (l : List 'A) =>
    match l with
    | Cons h t =>
      Some t
    | Nil =>
      None
    end
in
  
(* Returns Some Nil on successul match. None otherwise. *)
let list_eq_helper =
  tfun 'A =>
  fun (eq : 'A -> 'A -> Bool) =>
  fun (l1 : List 'A) =>
  fun (l2 : List 'A) =>
    let folder = @list_foldl 'A (Option (List 'A)) in
    let init = Some l2 in
    let iter =
      fun (z : Option (List 'A)) =>
      fun (h1 : 'A) =>
        match z with
        | Some ll2 =>
          let headF = @list_head 'A in
          let h2o = headF ll2 in
          match h2o with
          | Some h2 =>
            let eqb = eq h1 h2 in
            match eqb with
            | True =>
              let tailF = @list_tail 'A in
              tailF ll2
            | False =>
              None
            end
          | None =>
            None
          end
        | None =>
          None
        end
    in
      folder iter init l1
in

let list_eq =
  tfun 'A =>
  fun (f : 'A -> 'A -> Bool) =>
  fun (l1 : List 'A) =>
  fun (l2 : List 'A) =>
    let eqh = @list_eq_helper 'A in
    let res = eqh f l1 l2 in
    match res with
    | Some l =>
      match l with
      | Nil =>
        True
      | _ =>
        False
      end
    | _ =>
      False
    end
in
  
let list_int_eq_t = @list_eq Int in

let int_eq =
  fun (a : Int) =>
  fun (b : Int) =>
    builtin eq a b
in

let list_int_eq = list_int_eq_t int_eq in

let list_sort =
  tfun 'A =>
  fun (f : 'A -> 'A -> Int) =>
  fun (l_h : List 'A) =>
    (* Let us define a lesser_than and equals function for easier use. *)
    let flt_h = fun (a : 'A) => fun (b : 'A) =>
      let r = f a b in
      let zero = 0 in
        builtin lt r zero
    in
    let feq_h = fun (a : 'A) => fun (b : 'A) =>
      let r = f a b in
      let zero = 0 in
        builtin eq r zero
    in
    let list_sort_helper =
      tfun 'A =>
      fun (flt : 'A -> 'A -> Bool) =>
      fun (feq : 'A -> 'A -> Bool) =>
      fun (l : List 'A) =>
        (* The accumulator is a pair of lists. The first one is empty *)
        (* initially while the second one is "l" initially. After "n" *)
        (* steps, the first one will contain the sorted list and second *)
        (* one will be empty. Each step shifts the largest element. *)
        let folder = @list_foldl 'A (Pair (List 'A) (List 'A)) in
        let nil = Nil in
        let init = Pair {(List 'A) (List 'A)} nil l in
        let iter =
          fun (z : Pair (List 'A) (List 'A)) =>
          fun (h : 'A) =>
            let maxer = @list_max 'A in
            let skipper = @list_skip_once 'A in
            match z with
            | Pair x y =>
              let max_el_opt = maxer flt y in
              let max_el =
                match max_el_opt with
                | Some m =>
                  m
                | None =>
                  h                 (* this will never happen *)
                end
              in
              let new_y = skipper feq max_el y in
              let new_x = Cons {'A} max_el x in
              Pair {(List 'A) (List 'A)} new_x new_y
            end
      in
        folder iter init l
    in
      let helper = @list_sort_helper 'A in
      let res = helper flt_h feq_h l_h in
      match res with
      | Pair x y =>
        x
      end
in

let int_sort_t = @list_sort Int in

let f_compare =
  fun (a : Int) =>
  fun (b : Int) =>
    let lt = builtin lt a b in
    match lt with
    | True => -1
    | False =>
      let eq = builtin eq a b in
      match eq with
      | True => 0
      | False => 1
      end
    end
  in

let int_sort = int_sort_t f_compare in

let zero = 0 in
let one = 1 in
let two = 2 in
let three = 3 in
let four = 4 in

let nil = Nil in
let l0 = Cons {Int} two nil in
let l1 = Cons {Int} one l0 in
let l2 = Cons {Int} three l1 in
(* l3 = [4; 3; 1; 2] *)
let l3 = Cons {Int} four l2 in

let m0 = Cons {Int} four nil in
let m1 = Cons {Int} three m0 in
let m2 = Cons {Int} two m1 in
(* l3 = [1; 2; 3; 4] *)
let m3 = Cons {Int} one m2 in

let res1 = int_sort l3 in

list_int_eq res1 m3