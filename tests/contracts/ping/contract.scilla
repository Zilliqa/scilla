library PingPong

let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
      Cons {Message} msg nil_msg

let game_over = 0
let calling_pong = 1

(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract Ping

(* No immutable parameters *)
()

(* Mutable fields *)
field count : Int = 4
field pong_addr : Address = 0

transition Ping (sender: Address)
  one = 1;
  cnt <- count;
  pongAddr <- pong_addr;
  is_game_over = builtin lt cnt one;
  match is_game_over with
  | True =>
    msg = {_tag : Main; to : pongAddr; _amount : 0};
    msgs = one_msg msg;
    send msgs
  | False =>
    deccount = builtin sub cnt one;
    count := deccount;
    msg = {_tag : Pong; to : pongAddr; _amount : 0};
    msgs = one_msg msg;
    send msgs
  end
end

transition SetPongAddr (sender: Address, pongAddr : Address)
  pong_addr := pongAddr;
  accept
end
