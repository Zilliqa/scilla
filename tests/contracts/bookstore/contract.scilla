(* Associated Library *)
library BookStore

let one_msg =
  fun (msg: Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

(* error codes library *)
let code_success = Uint32 0
let code_book_not_found = Uint32 1
let code_book_found = Uint32 2
let code_not_authorized = Uint32 3


(* Contract Definition *)
contract BookStore
(owner: Address)

field storeName : String = "Bob's Bookstore"
field members: Map Uint32 String = Emp Uint32 String
(* lastID and lastSKU is the last ID issued *)
field lastID: Uint32 = Uint32 1
field lastSKU: Uint32 = Uint32 100
field bookInventory: Map Uint32 (Map Uint32 String) = Emp Uint32 (Map Uint32 String)

(* transitions *)


transition getStoreName()
    res <- storeName;
    msg = {_tag: "Main"; _recipient: _sender; _amount: Uint128 0; msg: res};
    msgs = one_msg msg;
    send msgs
end

(* @notice: add member is an example. It is not used in other functions. *)
(* @dev: in real contracts, a developer can use a members mapping to manage *)
(* access controls to grant a user permission to perform certain actions *)
(* (e.g. add/remove books) *)

transition addMember(name: String)

    is_authorized = builtin eq _sender owner;
    match is_authorized with
    | True => 
        (* Only the owner can add member *)
        mems <- members;
        new_member_name = name;
        last_id <- lastID;
        new_id = let one = Uint32 1 in
                    builtin add one last_id;
        add_mem =  builtin put mems new_id new_member_name;
        members := add_mem;
        lastID := new_id;

        msg = {_tag: "Main"; 
                _recipient: _sender; 
                _amount: Uint128 0; 
                msg: new_member_name};
        msgs = one_msg msg;
        send msgs 
    | False =>
        msg = {_tag: "Main";
                _recipient: _sender;
                _amount: Uint128 0;
                code: code_not_authorized};
        msgs = one_msg msg;
        send msgs
    end
end

transition addBook(bookname: String, author: String)

    (* @dev: Preconditions can be set to allow only members to add a book *)
    books <- bookInventory;
    last_sku_id <- lastSKU;
    new_sku_id = let one = Uint32 1 in builtin add last_sku_id one;

    (* constructs book model  *)
    model_book = Emp Uint32 String;
    bookname_added = let one = Uint32 1 in builtin put model_book one bookname;
    author_added = let two = Uint32 2 in builtin put bookname_added two author;

    add_to_inventory = builtin put books new_sku_id author_added;

    (* Change mutable fields once everything has been completed. *)
    bookInventory := add_to_inventory; 
    lastSKU := new_sku_id; 

    msg = {_tag: "Main"; 
            _recipient: _sender; 
            _amount: Uint128 0; 
            msg: new_sku_id};

    msgs = one_msg msg;
    send msgs 
end

transition removeBook(sku_id: Uint32)
    (* @dev: Preconditions can be set to allow only members to remove a book *)
    
    (* preconditions  *)
    books <- bookInventory;
    exist = builtin contains books sku_id;
    match exist with
    | False =>
        msg = {_tag: "Main"; 
                _recipient: _sender; 
                _amount: Uint128 0; 
                code: code_book_not_found};
        msgs = one_msg msg;
        send msgs
    | True =>
        removed = builtin remove books sku_id;
        bookInventory := removed;

        msg = {_tag: "Main"; 
            _recipient: _sender; 
            _amount: Uint128 0; 
            code: code_book_found};
        msgs = one_msg msg;
        send msgs
    end
end

transition updateBook(sku_id: Uint32, bookname: String, author: String)
    (* @dev: Preconditions can be set to allow only members to update a book *)
   
    (* preconditions  *)
    books <- bookInventory;
    exist = builtin contains books sku_id;
    match exist with
    | False =>
        removed = builtin remove books sku_id;
        bookInventory := removed;

        msg = {_tag: "Main"; 
                _recipient: _sender; 
                _amount: Uint128 0; 
                code: code_book_not_found};
        msgs = one_msg msg;
        send msgs
    | True =>
        (* constructs book model  *)
        model_book = Emp Uint32 String;
        bookname_added = 
            let one = Uint32 1 in builtin put model_book one bookname;
        author_added = 
            let two = Uint32 2 in builtin put bookname_added two author;

        add_to_inventory = builtin put books sku_id author_added;

        (* Change mutable fields once everything has been completed. *)
        bookInventory := add_to_inventory; 

        msg = {_tag: "Main"; 
                _recipient: _sender; 
                _amount: Uint128 0; 
                code: code_book_found};
        msgs = one_msg msg;
        send msgs
    end


end

