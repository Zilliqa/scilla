(* Associated Library *)
library BookStore

let one_msg =
  fun (msg: Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

(* error codes library *)
let code_success = Uint32 0
let code_book_not_found = Uint32 1
let code_book_found = Uint32 2
let code_not_authorized = Uint32 3
let code_invalid_params = Uint32 4


(* Contract Definition *)
contract BookStore
(owner: Address)

field storeName : String = "Bob's Bookstore"

(* Membership data consists of three attributes: Address, Name and typeOfMember*)
(* Equivalent member data in C++ struct *)
(* struct Member {                                                    *)
(*     Address address;                                               *)
(*     String name;                                                   *)
(*     Uint32 membershipType; // 0: Regular, 1: Premium, 2: Corporate *)
(* }                                                                  *)

field members: Map Address (Pair (String) (Uint32))
                = Emp Address (Pair (String) (Uint32))
(* lastID and lastSKU is the last ID issued *)
field lastID: Uint32 = Uint32 1
field lastSKU: Uint32 = Uint32 100
field bookInventory: Map Uint32 (Map Uint32 String) 
                        = Emp Uint32 (Map Uint32 String)

(* transitions *)


transition getStoreName()
    res <- storeName;
    msg = {_tag: "Main"; _recipient: _sender; _amount: Uint128 0; msg: res};
    msgs = one_msg msg;
    send msgs
end

(* @notice: add member is an example. It is not used in other functions. *)
(* @dev: in real contracts, a developer can use a members mapping to manage *)
(* access controls to grant a user permission to perform certain actions *)
(* (e.g. add/remove books) *)

transition addMember(name: String, addr: Address, memberType: Uint32)

    is_authorized = builtin eq _sender owner;
    match is_authorized with
    | True => 
        (* Only the owner can add member *)
        
        (* Check if membership type is valid. *)
        valid_type = let three = Uint32 3 in
                        builtin lt memberType three;
        match valid_type with
        | True =>
            mems <- members;
            p = Pair {String Uint32} name memberType;
            add_mem = builtin put mems addr p;
            members:= add_mem;

            msg = {_tag: "Main"; 
                    _recipient: _sender; 
                    _amount: Uint128 0; 
                    code: code_success};
            msgs = one_msg msg;
            send msgs 
        | False =>
            msg = {_tag: "Main";
                    _recipient: _sender;
                    _amount: Uint128 0;
                    code: code_invalid_params};
            msgs = one_msg msg;
            send msgs
        end
    | False =>
        msg = {_tag: "Main";
                _recipient: _sender;
                _amount: Uint128 0;
                code: code_not_authorized};
        msgs = one_msg msg;
        send msgs
    end
end

transition addBook(bookname: String, author: String)

    (* @dev: Preconditions can be set to allow only members to add a book *)
    books <- bookInventory;
    last_sku_id <- lastSKU;
    new_sku_id = let one = Uint32 1 in builtin add last_sku_id one;

    (* constructs book model  *)
    model_book = Emp Uint32 String;
    bookname_added = let one = Uint32 1 in builtin put model_book one bookname;
    author_added = let two = Uint32 2 in builtin put bookname_added two author;

    add_to_inventory = builtin put books new_sku_id author_added;

    (* Change mutable fields once everything has been completed. *)
    bookInventory := add_to_inventory; 
    lastSKU := new_sku_id; 

    msg = {_tag: "Main"; 
            _recipient: _sender; 
            _amount: Uint128 0; 
            msg: new_sku_id};

    msgs = one_msg msg;
    send msgs 
end

transition removeBook(sku_id: Uint32)
    (* @dev: Preconditions can be set to allow only members to remove a book *)
    
    (* preconditions  *)
    books <- bookInventory;
    exist = builtin contains books sku_id;
    match exist with
    | False =>
        msg = {_tag: "Main"; 
                _recipient: _sender; 
                _amount: Uint128 0; 
                code: code_book_not_found};
        msgs = one_msg msg;
        send msgs
    | True =>
        removed = builtin remove books sku_id;
        bookInventory := removed;

        msg = {_tag: "Main"; 
            _recipient: _sender; 
            _amount: Uint128 0; 
            code: code_book_found};
        msgs = one_msg msg;
        send msgs
    end
end

transition updateBook(sku_id: Uint32, bookname: String, author: String)
    (* @dev: Preconditions can be set to allow only members to update a book *)
   
    (* preconditions  *)
    books <- bookInventory;
    exist = builtin contains books sku_id;
    match exist with
    | False =>
        msg = {_tag: "Main"; 
                _recipient: _sender; 
                _amount: Uint128 0; 
                code: code_book_not_found};
        msgs = one_msg msg;
        send msgs
    | True =>
        (* constructs book model  *)
        model_book = Emp Uint32 String;
        bookname_added = 
            let one = Uint32 1 in builtin put model_book one bookname;
        author_added = 
            let two = Uint32 2 in builtin put bookname_added two author;

        add_to_inventory = builtin put books sku_id author_added;

        (* Change mutable fields once everything has been completed. *)
        bookInventory := add_to_inventory; 

        msg = {_tag: "Main"; 
                _recipient: _sender; 
                _amount: Uint128 0; 
                code: code_book_found};
        msgs = one_msg msg;
        send msgs
    end


end

