scilla_version 0

import ListUtils

(* Registered DEX : P2P Token Trades with pre-approval of token contracts    *)
(* Disclaimer: This contract is experimental and meant for testing purposes only *)
(* DO NOT USE THIS CONTRACT IN PRODUCTION *)

library RegisteredDex

(* Event for errors *)
let make_error_event =
  fun (location: String) =>
  fun (msg: String) =>
    { _eventname : "Error" ; raisedAt: location; message: msg}

(* Type of tokens with which this exchange can interact *)
type Token = ByStr20
  with
    balances_map : Map ByStr20 Uint128
  end

(* Order = { tokenA, valueA, tokenB, valueB } *)
type Order =
| Order of Token Uint128 Token Uint128

(* OrderInfo = { tokenOwnerAddress, expirationBlock } *)
type OrderInfo =
| OrderInfo of ByStr20 BNum

(* Create an orderID based on the hash of the parameters *)
let createOrderId = 
  fun (order: Order) =>
    builtin sha256hash order

(* Create one transaction message *)
let transaction_msg =
  (* REMOTE READ: recipient is always a token contract, since it performs the actual transfer. *)
  fun (recipient : Token) =>
  fun (tag : String) =>
  fun (transferFromAddr: ByStr20) =>
  fun (transferToAddr: ByStr20) =>
  fun (transferAmt: Uint128) =>
    {_tag : tag; _recipient : recipient; _amount : Uint128 0;
     from: transferFromAddr; to: transferToAddr; tokens: transferAmt }

(* Wrap one transaction message as singleton list *)
let transaction_msg_as_list =
  (* REMOTE READ: recipient is always a token contract, since it performs the actual transfer. *)
  fun (recipient : Token) =>
  fun (tag : String) =>
  fun (transferFromAddr: ByStr20) =>
  fun (transferToAddr: ByStr20) =>
  fun (transferAmt: Uint128) =>
    let one_msg = 
      fun (msg : Message) => 
        let nil_msg = Nil {Message} in
        Cons {Message} msg nil_msg in
    let msg = transaction_msg recipient tag transferFromAddr transferToAddr transferAmt in
    one_msg msg

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract SimpleDex
(contractOwner: ByStr20)

(* Valid tokens : mapping ByStr20 => Token *)
(* Users supply the token address. The Token version of the addres is stored in this map. *)
(* REMOTE READ: Entries in the map are checked for validity upon deployment. *)
(* REMOTE READ: No further dynamic checks necessary, since every access is checked statically. *)
field valid_tokens : Map ByStr20 Token = Emp ByStr20 Token

(* Orderbook: mapping (orderIds => ( (tokenA, valueA) (tokenB, valueB) )) *)
(* @param: tokenA: Contract of token A *)
(* @param: valueA: total units of token A offered by maker *)
(* @param: tokenB: Contract of token B *)
(* @param: valueB: total units of token B requsted by maker *)
(* REMOTE READ: Order type contains Token subvalue, so entries in the map are checked for validity upon deployment. *)
(* REMOTE READ: No further dynamic checks necessary, since every access is checked statically. *)
field orderbook : Map ByStr32 Order
                  = Emp ByStr32 Order
(* Order info stores the mapping ( orderId => (tokenOwnerAddress, expirationBlock)) *)
field orderInfo : Map ByStr32 OrderInfo = Emp ByStr32 OrderInfo

(* Ledger of how much the _sender can claim from the contract *)
(* mapping ( walletAddress => mapping (tokenContracts => amount) ) *)
(* REMOTE READ: All Token entries in the map are checked for validity upon deployment. *)
(* REMOTE READ: No further dynamic checks necessary, since every access is checked statically. *)
field pendingReturns : Map ByStr20 (Map Token Uint128) = Emp ByStr20 (Map Token Uint128)

(* Maker creates an order to exchange valueA of tokenA for valueB of tokenB *)
(* REMOTE READ: tokenA and tokenB are not checked for existence of balances_map, *)
(* because we pull the Token version from valid_tokens, which have already been checked. *)
transition makeOrder(tokenA: ByStr20, valueA: Uint128, tokenB: ByStr20, valueB: Uint128, expirationBlock: BNum)
  currentBlock <- & BLOCKNUMBER;
  validExpirationBlock =  let minBlocksFromCreation = Uint128 50 in
                          let minExpiration = builtin badd currentBlock minBlocksFromCreation in
                          builtin blt minExpiration expirationBlock;
  match validExpirationBlock with
  | True =>
    (* REMOTE READ: Fetch Token versions of ByStr20 contracts. The contents of *)
    (* valid_tokens have already been checked, so no need to re-check. *)
    valid_token_a_opt <- valid_tokens[tokenA];
    valid_token_b_opt <- valid_tokens[tokenB];
    valid_tokens = Pair {(Option Token) (Option Token)} valid_token_a_opt valid_token_b_opt;
    match valid_tokens with
    | Pair (Some valid_token_a) (Some valid_token_b) =>

      (* REMOTE READ: do not create order unless balance is sufficient *)
      token_balance_opt <- valid_token_a.balances_map[_sender];
      token_balance = match token_balance_opt with | Some v => v | None => Uint128 0;
      sufficient_balance = uint128_le valueA token_balance;
      match sufficient_balance with
      | True =>
        (* Creates a new order *)
        newOrder = Order valid_token_a valueA valid_token_b valueB;
        orderId = createOrderId newOrder;
        orderbook[orderId] := newOrder;

        (* Updates orderInfo with maker's address and expiration blocknumber *)
        p = OrderInfo _sender expirationBlock; 
        orderInfo[orderId] := p;

        e = {_eventname: "Order Created"; hash: orderId };
        event e;

        (* Transfer tokens from _sender to the contract address  *)
        msgs = let tag = "TransferFrom" in 
               transaction_msg_as_list tokenA tag _sender _this_address valueA;
        send msgs
      | False =>
        e = let func = "makeOrder" in
            let error_msg = "Insufficient token balance to make order" in 
            make_error_event func error_msg;
        event e
      end
    | _ 
      e = let func = "makeOrder" in
          let error_msg = "Unsupported token" in 
          make_error_event func error_msg;
      event e
    end    
  | False =>
    e = let func = "makeOrder" in
        let error_msg = "Expiration block must be at least 50 blocks more than current block" in 
        make_error_event func error_msg;
    event e
  end
end

(* Taker fills an order *)
transition fillOrder(orderId: ByStr32)
  getOrder <- orderbook[orderId];
  match getOrder with
  | Some (Order tokenA valueA tokenB valueB)=>
    (* Check the expiration block *)
    optionOrderInfo <- orderInfo[orderId];
    match optionOrderInfo with
    | Some (OrderInfo makerAddr expirationBlock) =>
      currentBlock <- & BLOCKNUMBER;
      blockBeforeExpiration = builtin blt currentBlock expirationBlock;
      match blockBeforeExpiration with
      | True =>
        (* REMOTE READ: do not fill order unless balance is sufficient *)
        token_balance_opt <- tokenB.balances_map[_sender];
        token_balance = match token_balance_opt with | Some v => v | None => Uint128 0;
        sufficient_balance = uint128_le valueB token_balance
        match sufficient_balance with
        | True =>
          (* Delete orders from the orderbook and orderinfo *)
          delete orderInfo[orderId];
          delete orderbook[orderId];
          (* Fill order immediately *)
          e = {_eventname: "Order Filled"; hash: orderId };
          event e;

          (* Transfer tokens from _sender to maker  *)
          msgs_b = let tag = "TransferFrom" in 
                   transaction_msg_as_list tokenB tag _sender makerAddr valueB;
          msgs_a = let tag = "TransferFrom" in
                   transaction_msg_as_list tokenA tag _this_address _sender valueA;
          msgs = list_append msgs_a msgs_b;
          send msgs
        | False =>        
          e = let func = "fillOrder" in
              let error_msg = "Insufficient token balance to fill order" in 
              make_error_event func error_msg;
          event e
      | False =>
        e = let func = "fillOrder" in
            let error_msg = "Current block number exceeds the expiration block set" in 
            make_error_event func error_msg;
        event e
      end
    | None => 
      e = let func = "fillOrder" in
          let error_msg = "OrderId not found" in 
          make_error_event func error_msg;
      event e
    end
  | None =>
    e = let func = "fillOrder" in
        let error_msg = "OrderId not found" in 
        make_error_event func error_msg;
    event e
  end
end

(* Maker can cancel his order *)
transition cancelOrder(orderId: ByStr32)
  getOrderInfo <- orderInfo[orderId];
  match getOrderInfo with
  | Some (OrderInfo makerAddr _) => 
    checkSender = builtin eq makerAddr _sender;
    match checkSender with
    | True =>
      (* Sender is the maker, proceed with cancellation *)
      fetchOrder <- orderbook[orderId];
      match fetchOrder with
      | Some (Order tokenA valueA _ _)=>
        (* Delete orders from the orderbook and orderinfo *)
        delete orderInfo[orderId];
        delete orderbook[orderId];

        (* REMOTE READ: No reason to check token balance - we have already secured the tokens *)

        e = {_eventname: "Cancel order successful"; hash: orderId };
        event e;
        
        (* Transfer tokens from _sender to the contract address  *)
        msgs = let tag = "TransferFrom" in 
               transaction_msg_as_list tokenA tag _this_address _sender valueA;
        send msgs

      | None =>
        e = let func = "cancelOrder" in
            let error_msg = "OrderID not found" in 
            make_error_event func error_msg;
        event e
      end
    | False =>
      (* Unauthorized transaction *)
      e = let func = "cancelOrder" in
          let error_msg = "Sender is not maker of the order" in 
      make_error_event func error_msg;
      event e
    end
  | None =>
    (* Order ID not found *)
    e = let func = "cancelOrder" in
        let error_msg = "OrderID not found" in 
        make_error_event func error_msg;
    event e
  end
end

(* REMOTE READ: new_token is checked for existence of balances_map. *)
transition registerToken ( new_token : Token)
  sender_is_owner = builtin eq contractOwner _sender;
  match sender_is_owner with
  | True =>
    (* REMOTE READ: Get pure ByStr20 from address type. *)
    address = builtin address_to_bystr20 Token;
    (* REMOTE READ: new_token is validated, so can just be added. *)
    valid_tokens[address] := new_token
  | False =>
    e = let func = "registerToken" in
        let error_msg = "Unauthorized registration of token" in 
        make_error_event func error_msg;
    event e
  end
end